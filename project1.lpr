{
 если просто копируете, то УДАЛЯЙТЕ КОММЕНТАРИИ
 пишите только маленькие поправочные
 ПО МОЕМУ ОБЪЁМУ комментариев он вычисляет что это скорее всего писал я
 он меня ска ЗАПОМНИЛ с прошлого года
 И даёт какую-нибудь невъебенную задачу посложнее, дополняя эту
}
program project1;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}{$IFDEF UseCThreads}
  cthreads,
  {$ENDIF}{$ENDIF}
  Classes
  { you can add units after this };


type
  // сначала создадим новый тип записей, чтобы хранить рядом данные разных типов
  // Этот тип - информация об участнике соревнований
  // человек может иметь
  // тип записей - люди спортсмены (Person - пусть будет человек-спортсмен)
  // T перед Person означает тип (не обязательно можно и без неё)
  TPerson = record
     name: string;   // ФАМИЛИЯ спортсмена
     res: real;  // его РЕЗУЛЬТАТ (может быть и integer - если здесь поменять, то ничего не сломается)
     count: integer; // КОЛИЧЕСТВО ПОПЫТОК
  end;

// зададим имя файла как константу - так будет легче использовать в основной программе
// може тпотребоваться получать имя файла от пользователя(как он решит)
const
  FILE_NAME = 'text.txt';

{
  ЗДЕСЬ ВАЖНОЕ УТОЧНЕНИЕ
  Тереньтич обычно даёт на лекциях,
  чтобы в функцию передавалось имя файла вместо файловой переменной,
  но в ДАННОМ СЛУЧАЕ УДОБНЕЕ передавать файловую переменную,
  чтобы не открывать файл заново и не переходить на нужную строчку
}

{Получаем из файла данные об одном участнике}
// считаем, чтострока в файле выглядит так "<фамилия участника> <результат> <кол-во попыток>"
// "var f: textfile" - т.к. функции чтения-записи(readln, writeln и тд) ИЗМЕНЯЮТ файловую переменную 'f'
// "var pers: Person;" т.к. мы изменяем передаваемую переменную, в которой сохраним данные об участнике
procedure GetOne(var f:textfile; var pers: TPerson);
// вспомогательная буферная переменная,
// для посимвольного считывания из файла, при получении ФАМИЛИИ спортсмена
var ch: char;
begin
  // задаём значения по умолчанию
  // их можно было использоватть в выражениях
  // То же самое можно было сделать в объявлении типа,
  // но я не знаю давал ли он вам как использовать такой синтаксис
  pers.name := '';
  pers.res := 0;
  pers.count := 0;

  // считаем один символ вне цикла, чтобы заполнить переменную ch
  // и не вылетить из условия цикла
  read(f, ch);
  // получаем фамилию спортсмена ДО ПЕРВОГО ПОПАВШЕГОСЯ ПРОБЕЛА
  while(ch <> ' ') do
  begin
    pers.name := pers.name + ch;
    read(f, ch);
  end;

  // здесь ch = ' ', значит получили фамилию спротсмена

  // дальше считваем
  // РЕЗУЛЬТАТ
  read(f, pers.res);     // read - чтобы НЕ перейти на другую строку
  // КОЛИЧЕСТВО ПОПЫТОК
  readln(f, pers.count); // readLN - чтобы ПЕРЕЙТИ на другую строчку
end;

{глобальные переменые - т.е. используются в основной программе}
var temp: TPerson; // Вспомогательная переменная чтобы считывать записи о людях из файла
    best: TPerson; // Победитель соревнований
    f: textfile;
// основная программа - что запускает пользователь
begin
  // открываем файл на чтение
  AssignFile(f, FILE_NAME);
  Reset(f);

  {Находим Победителя соревнований}

  // Т.к. не прочитали других спортсменов
  // то первый спортсмен в файле является ПОБЕДИТЕЛЕМ НА ДАННЫЙ МОМЕНТ
  GetOne(f, temp);
  best := temp;

  // Перебираем всех остальны спортсменов из файла
  // и сравниваем с ЛУЧШИМ - победителем других
  while(not eof(f)) do
  begin
    // Получили одного спортсмена
    GetOne(f, temp);

    // Если результаты равны то выбираем того, у кого меньше попыток
    if (temp.res = best.res) then
    begin
      // из условия ДОЛЖНО ОБЯЗАТЕЛЬНО у кого-то быть меньше количесвто попыток
      if (temp.count < best.count) then best := temp; // второе условие не надо, тк best.count будет < temp.count
    end
    // если результаты различны, то выбираем того у кого он выше
    else if (temp.res > best.res) then best := temp; // второе условие не надо, тк best.res будет > temp.res
  end;

  // закрываем файл
  closefile(f);

  {теперь нам нужно добавить ФАМИЛИЮ победителя в конец ИСХОДНОГО файла}
  // Открываем файл на добавление в конец
  AssignFile(f, FILE_NAME);
  Append(f);
  // записываем победителя
  writeln(f, 'The Winner: ' + best.name);
  // закрываем файл
  closefile(f);

// здесь не надо добавлять в конце программы readln для задержки перед выходом,
// тк нам нужно будет только запускать программу и потом проверять файл
//readln;
end.
